## Set up

```bash
yarn install
```

## Requirements
- Newer than or equal to `forge 0.2.0 (b174c3a)`.

## Build and Test

Make sure you have [Foundry](https://github.com/foundry-rs/foundry) installed

Build the contracts using the below command.

```bash
$ yarn build
```

Run unit tests
```bash
$ yarn test
```

Run integration tests

Before running integration tests, you need to make a `packages/contracts/test/build_integration` directory, download the zip file from the following link, and place its unzipped directory under that directory.
https://drive.google.com/file/d/13_RItK372JdfQFM3TmQFU_svN7q0k5iF/view?usp=drive_link

Then, move `email_auth.zkey` and `email_auth.wasm` in the unzipped directory `params` to `build_integration`. 


Run each integration tests **one by one** as each test will consume lot of memory.
```bash
Eg: forge test --match-test 'testIntegration_Account_Recovery' -vvv --ffi
```
#### Deploy Common Contracts.
You need to deploy common contracts, i.e., `ECDSAOwnedDKIMRegistry`, `Verifier`, and implementations of `EmailAuth` and `SimpleWallet`, only once before deploying each wallet.
1. `cp .env.sample .env`. 
2. Write your private key in hex to the `PRIVATE_KEY` field in `.env`.
3. `source .env`
4. `forge script script/DeployCommons.s.sol:Deploy --rpc-url $RPC_URL --chain-id $CHAIN_ID --broadcast -vvvv`

#### Deploy Each Wallet.
After deploying common contracts, you can deploy a proxy contract of `SimpleWallet`, which is an example contract supporting our email-based account recovery.
1. Check that the env values of `DKIM`, `VERIFIER`, `EMAIL_AUTH_IMPL`, and `SIMPLE_WALLET_IMPL` are the same as those output by the `DeployCommons.s.sol` script.
2. `forge script script/DeploySimpleWallet.s.sol:Deploy --rpc-url $RPC_URL --chain-id $CHAIN_ID --broadcast -vvvv` 

## Specification
There are four main contracts that developers should understand: `IDKIMRegistry`, `Verifier`, `EmailAuth` and `EmailAccountRecovery`.
While the first three contracts are agnostic to usecases of our SDK, the last one is an abstract contract only for our email-based account recovery.

### `IDKIMRegistry` Contract
It is an interface of the DKIM registry contract that traces public keys registered for each email domain in DNS.
It is defined in [the zk-email library](https://github.com/zkemail/zk-email-verify/blob/main/packages/contracts/interfaces/IDKIMRegistry.sol).
It requires a function `isDKIMPublicKeyHashValid(string domainName, bytes32 publicKeyHash) view returns (bool)`: it returns true iff the given hash of the public key `publicKeyHash` is registered for the given email-domain name `domainName`.

One of its implementations is [`ECDSAOwnedDKIMRegistry`](https://github.com/zkemail/ether-email-auth/blob/main/packages/contracts/src/utils/ECDSAOwnedDKIMRegistry.sol).
It stores the Ethereum address `signer` who can update the registry.

### `Verifier` Contract
It has a responsibility to verify a ZK proof for the [`email_auth.circom` circuit](https://github.com/zkemail/ether-email-auth/blob/main/packages/circuits/src/email_auth.circom).
It is implemented in [`utils/Verifier.sol`](https://github.com/zkemail/ether-email-auth/blob/main/packages/contracts/src/utils/Verifier.sol).

It defines a structure `EmailProof` consisting of the ZK proof and data of the instances necessary for proof verification as follows:
```
struct EmailProof {
    string domainName; // Domain name of the sender's email
    bytes32 publicKeyHash; // Hash of the DKIM public key used in email/proof
    uint timestamp; // Timestamp of the email
    string maskedSubject; // Masked subject of the email
    bytes32 emailNullifier; // Nullifier of the email to prevent its reuse.
    bytes32 accountSalt; // Create2 salt of the account
    bool isCodeExist; // Check if the account code is exist
    bytes proof; // ZK Proof of Email
}
```

Using that, it provides a function `function verifyEmailProof(EmailProof memory proof) public view returns (bool)`: it takes as input the `EmailProof proof` and returns true iff the proof is valid. Notably, it internally calls [`Groth16Verifier.sol`](https://github.com/zkemail/ether-email-auth/blob/main/packages/contracts/src/utils/Groth16Verifier.sol) generated by snarkjs from the verifying key of the [`email_auth.circom` circuit](https://github.com/zkemail/ether-email-auth/blob/main/packages/circuits/src/email_auth.circom).

### `EmailAuth` Contract
It is a contract deployed for each email user to verify an email-auth message from that user. The structure of the email-auth message is defined as follows:
```
struct EmailAuthMsg {
    uint templateId; // The ID of the subject template that the email subject should satisfy.
    bytes[] subjectParams; // The parameters in the email subject, which should be taken according to the specified subject template.
    uint skipedSubjectPrefix; // The number of skiiped bytes in the email subject.
    EmailProof proof; // The email proof containing the zk proof and other necessary information for the email verification by the verifier contract.
}
``` 

It has the following storage variables.
- `address owner`: an address of the contract owner.
- `bytes32 accountSalt`: an `accountSalt` used for the CREATE2 salt of this contract.
- `DKIMRegistry dkim`: an instance of the DKIM registry contract.
- `Verifier verifier`: an instance of the Verifier contract.
- `mapping(uint=>string[]) subjectTemplates`: a mapping of the supported subject templates associated with its ID.  
- `mapping(bytes32â‡’bytes32) authedHash`: a mapping of the hash of the authorized message associated with its `emailNullifier`. 
- `uint lastTimestamp`: the latest `timestamp` in the verified `EmailAuthMsg`. 
- `mapping(bytes32=>bool) usedNullifiers`: a mapping storing the used `emailNullifier` bytes. 
- `bool timestampCheckEnabled`: a boolean whether timestamp check is enabled or not.

It provides the following functions.
- `initialize(address _initialOwner, bytes32 _accountSalt)`
    1. Set `owner=_initialOwner` .
    2. Set `accountSalt=_accountSalt`.
    3. Set `timestampCheckEnabled=true`.
- `updateDKIMRegistry(address _dkim)`
    1. Assert `msg.sender==owner`.
    2. Assert `_dkim` is not zero.
    3. Set `dkim=DKIMRegistry(_dkim)`.
- `updateVerifier(address _verifier)`
    1. Assert `msg.sender==owner`.
    2. Assert `_verifier` is not zero.
    3. Set `verifier=Verifier(_verifier)`.
- `dkimRegistryAddr() view returns (address)`
    Return `address(dkim)`
- `verifierAddr() view returns (address)`
    Return `address(verifier)` .
- `updateVerifier(address _verifierAddr)`
    1. Assert `msg.sender==owner` .
    2. Assert `_verifierAddr!=0`.
    3. Update `verifier` to `Verifier(_verifierAddr)`.
- `updateDKIMRegistry(address _dkimRegistryAddr)`
    1. Assert `msg.sender==owner` .
    2. Assert `_dkimRegistryAddr!=0`.
    3. Update `dkim` to `DKIMRegistry(_dkimRegistryAddr)`.
- `insertSubjectTemplate(uint _templateId, string[] _subjectTemplate)`
    1. Assert `_subjectTemplate.length>0` .
    2. Assert `msg.sender==owner`.
    3. Assert `subjectTemplates[_templateId].length == 0`, i.e., no template has not been registered with `_templateId`.
    4. Set  `subjectTemplates[_templateId]=_subjectTemplate`.
- `updateSubjectTemplate(uint _templateId, string[] _subjectTemplate)`
    1. Assert `_subjectTemplate.length>0` .
    2. Assert `msg.sender==owner`.
    3. Assert `subjectTemplates[_templateId].length != 0` , i.e., any template has been already registered with `_templateId`.
    4. Set  `subjectTemplates[_templateId]=_subjectTemplate`.
- `deleteSubjectTemplate(uint _templateId)`
    1. Assert `msg.sender==owner`.
    2. Assert `subjectTemplates[_templateId].length > 0`, i.e., any template has been already registered with `_templateId`.
    3. `delete subjectTemplates[_templateId]`.
- `computeMsgHash(bytes32 accountSalt, bool isCodeExist, uint templateId, bytes[] subjectParams) public view returns (bytes32)`
    1. Return `keccak256(accountAddr, templateId, isCodeExist, subjectParams)`
- `authEmail(EmailAuthMsg emailAuthMsg) returns (bytes32)`
    1. Assert `msg.sender==owner`.
    2. Let `string[] memory template = subjectTemplates[emailAuthMsg.templateId]`.
    3. Assert `template.length > 0`.
    4. Assert `dkim.isDKIMPublicKeyHashValid(emailAuthMsg.proof.domain, emailAuthMsg.proof.publicKeyHash)==true`.
    5. Assert `usedNullifiers[emailAuthMsg.proof.emailNullifier]==false` and set `usedNullifiers[emailAuthMsg.proof.emailNullifier]` to `true`. 
    6. Assert `accountSalt==emailAuthMsg.proof.accountSalt`.
    7. If `timestampCheckEnabled` is true, assert that `emailAuthMsg.proof.timestamp` is zero OR `lastTimestamp < emailAuthMsg.proof.timestamp`, and update `lastTimestamp` to `emailAuthMsg.proof.timestamp`.
    8. Construct an expected subject `expectedSubject` from `template` and the values of `emailAuthMsg.subjectParams`.
    9. Assert that `expectedSubject` is equal to `emailAuthMsg.proof.maskedSubject[skipedSubjectPrefix:]` , i.e., the string of `emailAuthMsg.proof.maskedSubject` from the `skipedSubjectPrefix`-th byte.
    10. Assert `verifier.verifyEmailProof(emailAuthMsg.proof)==true`.
    11. Compute `bytes32 msgHash = computeMsgHash(emailAuthMsg.proof.accountSalt, emailAuthMsg.proof.isCodeExist, emailAuthMsg.templateId, emailAuthMsg.subjectParams)`. 
    12. Set `authedHash[emailAuthMsg.proof.emailNullifier]=msgHash`.
    13. Return `msgHash`.
- `isValidSignature(bytes32 _hash, bytes memory _signature) public view returns (bytes4 magicValue)`
    1. Parse `_signature` as `(bytes32 emailNullifier)`.
    2. If `authedHash[emailNullifier]== _hash`, return `0x1626ba7e`; otherwise return `0xffffffff`.
- `setTimestampCheckEnabled(bool enabled) public`
    1. Assert `msg.sender==owner`.
    2. Set `timestampCheckEnabled` to `enabled`.

### `EmailAccountRecovery` Contract
It is an abstract contract for each wallet contract to implement our email-based account recovery. **Each wallet provider only needs to implement the following functions in the wallet contract.**
- `acceptanceSubjectTemplates() public view virtual returns (string[][])`: it returns multiple subject templates for an email to accept becoming a guardian.
- `recoverySubjectTemplates() public view virtual returns (string[][])`: it returns multiple subject templates for an email to confirm the account recovery.
- `acceptGuardian(address guardian, uint templateIdx, bytes[] subjectParams, bytes32 emailNullifier) internal virtual`: it takes as input the Ethereum address `guardian` corresponding to the guardian's email address, the index `templateIdx` of the subject template in the output of `acceptanceSubjectTemplates()`, the parameter values of the variable parts `subjectParams` in the template `acceptanceSubjectTemplates()[templateIdx]`, and an email nullifier `emailNullifier`. It is called after verifying the email-auth message to accept the role of the guardian; thus you can assume the arguments are already verified. 
- `processRecovery(address guardian, uint templateIdx, bytes[] subjectParams, bytes32 emailNullifier) internal virtual`: it takes as input the Ethereum address `guardian` corresponding to the guardian's email address, the index `templateIdx` of the subject template in the output of `recoverySubjectTemplates()`, the parameter values of the variable parts `subjectParams` in the template `recoverySubjectTemplates()[templateIdx]`, and an email nullifier `emailNullifier`. It is called after verifying the email-auth message to confirm the recovery; thus you can assume the arguments are already verified.
- `completeRecovery() external virtual`: it can be called by anyone, in particular a Relayer, when completing the account recovery. It should first check if the condition for the account recovery holds and then update the owner address in the wallet contract.

It also provides the following entry functions with their default implementations, called by the Relayer.
- `handleAcceptance(EmailAuthMsg emailAuthMsg, uint templateIdx) external`
    1. Let `address guardian = CREATE2(emailAuthMsg.proof.accountSalt, ERC1967Proxy.creationCode, emailAuthImplementation(), (emailAuthMsg.proof.accountSalt))`.
    2. Assert that the contract of `guardian` has not been deployed.
    3. Let `uint templateId = keccak256(EMAIL_ACCOUNT_RECOVERY_VERSION_ID, "ACCEPTANCE", templateIdx)`.
    4. Assert that  `templateId` is equal to `emailAuthMsg.templateId`.
    5. Assert that `emailAuthMsg.proof.isCodeExist` is true.
    6. Deploy the proxy contract of `emailAuthImplementation()`. Its salt is `emailAuthMsg.proof.accountSalt` and its initialization parameter is  `mailAuthMsg.proof.accountSalt`.
    7. Call `EmailAuth(guardian).setDkim(dkim())`.
    8. Call `EmailAuth(guardian).setVerifier(verifier())`.
    9. For each `template` in `acceptanceSubjectTemplates()` along with its index `idx`, call `EmailAuth(guardian).insertSubjectTemplate(keccak256(EMAIL_ACCOUNT_RECOVERY_VERSION_ID, "ACCEPTANCE", idx), template)`.
    10. For each `template` in `recoverySubjectTemplates()` along with its index `idx`, call `EmailAuth(guardian).insertSubjectTemplate(keccak256(EMAIL_ACCOUNT_RECOVERY_VERSION_ID, "RECOVERY", idx), template)`.
    11. Assert that `EmailAuth(guardian).authEmail(1emailAuthMsg)` returns no error.
    12. Call `acceptGuardian(guardian, templateIdx, emailAuthMsg.subjectParams, emailAuthMsg.proof.emailNullifier)`.
- `handleRecovery(EmailAuthMsg emailAuthMsg, uint templateIdx) external`
    1. Let `address guardian = CREATE2(emailAuthMsg.proof.accountSalt, ERC1967Proxy.creationCode, emailAuthImplementation(), (emailAuthMsg.proof.accountSalt))`.
    2. Assert that the contract of `guardian` has been already deployed.
    3. Let `uint templateId=keccak256(EMAIL_ACCOUNT_RECOVERY_VERSION_ID, "RECOVERY", templateIdx)`.
    4. Assert that  `templateId` is equal to `emailAuthMsg.templateId`.
    5. Assert that `EmailAuth(guardian).authEmail(emailAuthMsg)` returns no error.
    6. Call `processRecovery(guardian, templateIdx, emailAuthMsg.subjectParams, emailAuthMsg.proof.emailNullifier)`.